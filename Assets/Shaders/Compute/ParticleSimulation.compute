#pragma kernel UpdateArgs
#pragma kernel Emit
#pragma kernel Simulate
#pragma target 5.0

#define THREAD_COUNT_1D 256

struct Particle
{
    float4 lifetime; // x: current age, y: max lifetime
    float4 velocity;
    float4 position;
    float4 color;
};

// --- GPU Buffers ---
RWStructuredBuffer<Particle> _Particles;
RWStructuredBuffer<uint> _DeadPool;
RWStructuredBuffer<uint> _AliveIndices_A;
RWStructuredBuffer<uint> _AliveIndices_B;
RWStructuredBuffer<uint> _Counters;       // [0]=dead_count, [1]=alive_A_count, [2]=alive_B_count
RWStructuredBuffer<uint> _IndirectArgs;

// --- Uniforms ---
float _DeltaTime;
uint _PingPong_A;
uint _PingPong_B;
uint _EmissionCount;
float _MinLifetime;
float _MaxLifetime;
float _MinInitialSpeed;
float _MaxInitialSpeed;
float3 _EmitterPosition;
float3 _EmitterDirection; // 用于随机模式
float _EmitterRadius;
float3 _Seeds;
uint _AffectedByGravity;

// 【新增】用于控制逻辑的 Uniforms
uint _EmissionType;   // 0 for Random, 1 for Spiral
float _SpiralForce;   // 螺旋力强度
float _SpiralRadius;
float _SpiralHeight;
float _SpiralTurns;


float rand(float2 co)
{
    return frac(sin(dot(co, float2(12.9898, 78.233))) * 43758.5453);
}

// =========================================================================
// KERNEL 1: UpdateArgs
// =========================================================================
[numthreads(1, 1, 1)]
void UpdateArgs(uint3 id : SV_DispatchThreadID)
{
    _Counters[_PingPong_B] = 0;
    _IndirectArgs[1] = 0;
}

// =========================================================================
// KERNEL 2: Emit
// =========================================================================
[numthreads(THREAD_COUNT_1D, 1, 1)]
void Emit(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= _EmissionCount) return;

    uint dead_count;
    InterlockedAdd(_Counters[0], -1, dead_count);
    
    if (dead_count < 1)
    {
        // 如果没有可用粒子，把计数器加回来，防止无限递减
        InterlockedAdd(_Counters[0], 1);
        return;
    }
    
    // 【致命BUG修复】使用 dead_count - 1 作为索引，以正确读取池中最后一个有效元素。
    uint p_idx = _DeadPool[dead_count - 1];

    Particle p;
    p.lifetime = float4(0, lerp(_MinLifetime, _MaxLifetime, rand(id.xy + _Seeds.xy)), 0, 0);
    
    // 【修改】根据 _EmissionType 选择发射逻辑
    if (_EmissionType == 0) // Random Mode
    {
        // 自由漂浮发射 - 从一个球体内随机发射
        float3 randomOffset = float3(
            (rand(id.xy + _Seeds.xy) - 0.5) * 2.0,
            (rand(id.yx + _Seeds.yz) - 0.5) * 2.0,
            (rand(id.xy + _Seeds.zx) - 0.5) * 2.0
        );
        p.position = float4(_EmitterPosition + normalize(randomOffset) * _EmitterRadius * rand(id.xy + _Seeds.yx), 0);
        
        float3 direction = _EmitterDirection.x == 0 && _EmitterDirection.y == 0 && _EmitterDirection.z == 0 ?
                           normalize(randomOffset) :
                           _EmitterDirection;
        
        float speed = lerp(_MinInitialSpeed, _MaxInitialSpeed, rand(id.yx + _Seeds.zy));
        p.velocity = float4(direction * speed, 0);
    }
    else // Spiral Mode (Default)
    {
        float t = rand(id.xy + _Seeds.xy); // 随机参数t
        
        // 计算螺旋位置
        float angle = t * _SpiralTurns * 2.0 * 3.14159;
        float height = t * _SpiralHeight;
        float radius = _SpiralRadius * (1.0 - t); // 半径随高度递减
        
        float3 spiralPos = float3(
            cos(angle) * radius,
            height,
            sin(angle) * radius
        );
        p.position = float4(_EmitterPosition + spiralPos, 0);
        
        // 螺旋方向 - 切线方向
        float3 spiralDirection = normalize(float3(
            -sin(angle) * radius * _SpiralTurns * 2.0 * 3.14159 / _SpiralHeight,
            1.0,
            cos(angle) * radius * _SpiralTurns * 2.0 * 3.14159 / _SpiralHeight
        ));
        
        float speed = lerp(_MinInitialSpeed, _MaxInitialSpeed, rand(id.yx + _Seeds.zy));
        p.velocity = float4(spiralDirection * speed, 0);
    }

    float3 randomColor = float3(
        rand(id.xy + _Seeds.xy),
        rand(id.yx + _Seeds.yz),
        rand(id.xy + _Seeds.zx)
    );
    p.color = float4(randomColor, 1.0);

    _Particles[p_idx] = p;

    uint alive_insert_idx;
    InterlockedAdd(_Counters[_PingPong_A], 1, alive_insert_idx);
    _AliveIndices_A[alive_insert_idx] = p_idx;
}

// =========================================================================
// KERNEL 3: Simulate
// =========================================================================
[numthreads(THREAD_COUNT_1D, 1, 1)]
void Simulate(uint3 id : SV_DispatchThreadID)
{
    uint total_alive_count = _Counters[_PingPong_A];
    if (id.x >= total_alive_count) return;

    uint p_idx = _AliveIndices_A[id.x];
    Particle p = _Particles[p_idx];

    p.lifetime.x += _DeltaTime;

    if (p.lifetime.x >= p.lifetime.y)
    {
        uint dead_insert_idx;
        InterlockedAdd(_Counters[0], 1, dead_insert_idx);
        _DeadPool[dead_insert_idx] = p_idx;
    }
    else
    {
        if (_AffectedByGravity > 0)
        {
            p.velocity.y -= 9.81 * _DeltaTime;
        }
        
        // 【修改】只在螺旋模式下施加螺旋力
        if (_EmissionType == 1)
        {
            // 【修改】注释更新，更准确地描述行为
            // 施加一个螺旋形的力场来引导粒子运动
            float3 particlePos = p.position.xyz;
            float currentAngle = atan2(particlePos.z, particlePos.x);
            
            // 【修改】使用 uniform 变量而不是硬编码的数字
            float3 spiralForce3D = float3(
                -sin(currentAngle) * _SpiralForce,
                0.0,
                cos(currentAngle) * _SpiralForce
            );
            
            float time = p.lifetime.x;
            float noiseX = sin(particlePos.x * 0.01 + time * 0.5) * 0.1;
            float noiseY = sin(particlePos.y * 0.01 + time * 0.4) * 0.1;
            float noiseZ = sin(particlePos.z * 0.01 + time * 0.7) * 0.1;
            
            p.velocity.xyz += (spiralForce3D + float3(noiseX, noiseY, noiseZ)) * _DeltaTime;
        }
        
        p.position.xyz += p.velocity.xyz * _DeltaTime;
        
        _Particles[p_idx] = p;
        
        uint alive_insert_idx;
        InterlockedAdd(_Counters[_PingPong_B], 1, alive_insert_idx);
        _AliveIndices_B[alive_insert_idx] = p_idx;

        InterlockedAdd(_IndirectArgs[1], 1);
    }
}